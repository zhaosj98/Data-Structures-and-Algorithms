#pragma warning(disable:4996)
#include<iostream>
#include<cstdio>
using namespace std;
int main()
{
	/*将盘子按照不同的大小分组，可以分为第1组，第2组，...,第i组，...，第N组，其中第i+1组的盘子比第i组的盘子大，a_i表示第i组内的盘子数量*/
	/*对于第一组来说，将这一组从一根柱上移动到另一根柱上，如果考虑组内的顺序不变则需要移动2a_1-1次，如果不考虑组内的顺序而只是移动则需要a_1次*/
	/*用C0_i来表示从第1组到第i组的所有盘子不考虑顺序地从一根柱上移动到另一根柱上需要的次数，C1_i表示从第1组到第i组的所有盘子保持顺序不变地从一根柱上移动到另一根柱上需要的次数*/
	/*对于第i组(i>1)来说，将这一组从一根柱子上移动到另一根柱子上，如果不考虑顺序，则C0_i=2C0_(i-1)+a_i；如果考虑移动顺序，则有两种情况，如果a_i=1，则C1_i=2*C0_(i-1)+1，如果a_i>1则，C1_i=2*C0_(i-1)+C1_(i-1)+2*a_i */
	/*利用上面说明的公式可以给出以下程序*/
	int C0,C1, i, a_i, N, M;
	scanf("%d%d", &N, &M);
	C0 = 0;
	scanf("%d", &a_i);
	/*操作符的解释：C%=M表示对M求模，并且将结果赋给C，C<<=1表示将C向左移一位（相当于乘以2）并将结果赋给C，其他的类似*/
	/*关于求模的一些解释：(a+b)%M=(a%M+b%M)%M，(a*b)%M=((a%M)*(b%M))%M，因此不必最后在移动次数上求模（移动次数很可能太大而无法用int数保存），每一次都求模就可以了*/
	(--(C1 = (a_i << 1))) %= M; //计算第一组盘子保持顺序不变移动到另一个柱上需要的次数并对M求模
	(C0 = a_i) %= M; //计算第一组盘子不考虑顺序移动到另一个柱上需要的次数
	for (i = N;i > 1;--i)
	{
		scanf("%d", &a_i);
		if (a_i == 1)(++((C1 = C0) <<= 1)) %= M;  //a_i=1，则C1_i=2*C0_(i-1)+1
		else ((C1 += (C0 << 1)) += (a_i << 1)) %= M; //a_i>1则，C1_i=2*C0_(i-1)+C1_(i-1)+2*a_i 
		((C0 <<= 1) += a_i) %= M; //C0_i=2C0_(i-1)+a_i
	}
	printf("%d", C1);
}